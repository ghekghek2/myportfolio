{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { useEffect, useRef } from 'react';\nimport useSetState from '../useSetState';\nimport parseTimeRanges from '../misc/parseTimeRanges';\nexport default function createHTMLMediaHook(tag) {\n  return function (elOrProps) {\n    var element;\n    var props;\n    if (React.isValidElement(elOrProps)) {\n      element = elOrProps;\n      props = element.props;\n    } else {\n      props = elOrProps;\n    }\n    var _a = useSetState({\n        buffered: [],\n        time: 0,\n        duration: 0,\n        paused: true,\n        muted: false,\n        volume: 1,\n        playing: false\n      }),\n      state = _a[0],\n      setState = _a[1];\n    var ref = useRef(null);\n    var wrapEvent = function wrapEvent(userEvent, proxyEvent) {\n      return function (event) {\n        try {\n          proxyEvent && proxyEvent(event);\n        } finally {\n          userEvent && userEvent(event);\n        }\n      };\n    };\n    var onPlay = function onPlay() {\n      return setState({\n        paused: false\n      });\n    };\n    var onPlaying = function onPlaying() {\n      return setState({\n        playing: true\n      });\n    };\n    var onWaiting = function onWaiting() {\n      return setState({\n        playing: false\n      });\n    };\n    var onPause = function onPause() {\n      return setState({\n        paused: true,\n        playing: false\n      });\n    };\n    var onVolumeChange = function onVolumeChange() {\n      var el = ref.current;\n      if (!el) {\n        return;\n      }\n      setState({\n        muted: el.muted,\n        volume: el.volume\n      });\n    };\n    var onDurationChange = function onDurationChange() {\n      var el = ref.current;\n      if (!el) {\n        return;\n      }\n      var duration = el.duration,\n        buffered = el.buffered;\n      setState({\n        duration: duration,\n        buffered: parseTimeRanges(buffered)\n      });\n    };\n    var onTimeUpdate = function onTimeUpdate() {\n      var el = ref.current;\n      if (!el) {\n        return;\n      }\n      setState({\n        time: el.currentTime\n      });\n    };\n    var onProgress = function onProgress() {\n      var el = ref.current;\n      if (!el) {\n        return;\n      }\n      setState({\n        buffered: parseTimeRanges(el.buffered)\n      });\n    };\n    if (element) {\n      element = React.cloneElement(element, __assign(__assign({\n        controls: false\n      }, props), {\n        ref: ref,\n        onPlay: wrapEvent(props.onPlay, onPlay),\n        onPlaying: wrapEvent(props.onPlaying, onPlaying),\n        onWaiting: wrapEvent(props.onWaiting, onWaiting),\n        onPause: wrapEvent(props.onPause, onPause),\n        onVolumeChange: wrapEvent(props.onVolumeChange, onVolumeChange),\n        onDurationChange: wrapEvent(props.onDurationChange, onDurationChange),\n        onTimeUpdate: wrapEvent(props.onTimeUpdate, onTimeUpdate),\n        onProgress: wrapEvent(props.onProgress, onProgress)\n      }));\n    } else {\n      element = React.createElement(tag, __assign(__assign({\n        controls: false\n      }, props), {\n        ref: ref,\n        onPlay: wrapEvent(props.onPlay, onPlay),\n        onPlaying: wrapEvent(props.onPlaying, onPlaying),\n        onWaiting: wrapEvent(props.onWaiting, onWaiting),\n        onPause: wrapEvent(props.onPause, onPause),\n        onVolumeChange: wrapEvent(props.onVolumeChange, onVolumeChange),\n        onDurationChange: wrapEvent(props.onDurationChange, onDurationChange),\n        onTimeUpdate: wrapEvent(props.onTimeUpdate, onTimeUpdate),\n        onProgress: wrapEvent(props.onProgress, onProgress)\n      })); // TODO: fix this typing.\n    }\n    // Some browsers return `Promise` on `.play()` and may throw errors\n    // if one tries to execute another `.play()` or `.pause()` while that\n    // promise is resolving. So we prevent that with this lock.\n    // See: https://bugs.chromium.org/p/chromium/issues/detail?id=593273\n    var lockPlay = false;\n    var controls = {\n      play: function play() {\n        var el = ref.current;\n        if (!el) {\n          return undefined;\n        }\n        if (!lockPlay) {\n          var promise = el.play();\n          var isPromise = typeof promise === 'object';\n          if (isPromise) {\n            lockPlay = true;\n            var resetLock = function resetLock() {\n              lockPlay = false;\n            };\n            promise.then(resetLock, resetLock);\n          }\n          return promise;\n        }\n        return undefined;\n      },\n      pause: function pause() {\n        var el = ref.current;\n        if (el && !lockPlay) {\n          return el.pause();\n        }\n      },\n      seek: function seek(time) {\n        var el = ref.current;\n        if (!el || state.duration === undefined) {\n          return;\n        }\n        time = Math.min(state.duration, Math.max(0, time));\n        el.currentTime = time;\n      },\n      volume: function volume(_volume) {\n        var el = ref.current;\n        if (!el) {\n          return;\n        }\n        _volume = Math.min(1, Math.max(0, _volume));\n        el.volume = _volume;\n        setState({\n          volume: _volume\n        });\n      },\n      mute: function mute() {\n        var el = ref.current;\n        if (!el) {\n          return;\n        }\n        el.muted = true;\n      },\n      unmute: function unmute() {\n        var el = ref.current;\n        if (!el) {\n          return;\n        }\n        el.muted = false;\n      }\n    };\n    useEffect(function () {\n      var el = ref.current;\n      if (!el) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (tag === 'audio') {\n            console.error('useAudio() ref to <audio> element is empty at mount. ' + 'It seem you have not rendered the audio element, which it ' + 'returns as the first argument const [audio] = useAudio(...).');\n          } else if (tag === 'video') {\n            console.error('useVideo() ref to <video> element is empty at mount. ' + 'It seem you have not rendered the video element, which it ' + 'returns as the first argument const [video] = useVideo(...).');\n          }\n        }\n        return;\n      }\n      setState({\n        volume: el.volume,\n        muted: el.muted,\n        paused: el.paused\n      });\n      // Start media, if autoPlay requested.\n      if (props.autoPlay && el.paused) {\n        controls.play();\n      }\n    }, [props.src]);\n    return [element, state, controls, ref];\n  };\n}","map":null,"metadata":{},"sourceType":"module"}