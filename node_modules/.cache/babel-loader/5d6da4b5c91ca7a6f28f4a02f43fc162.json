{"ast":null,"code":"import { useEffect, useMemo, useState } from 'react';\nexport var ZoomState;\n(function (ZoomState) {\n  ZoomState[\"ZOOMING_IN\"] = \"ZOOMING_IN\";\n  ZoomState[\"ZOOMING_OUT\"] = \"ZOOMING_OUT\";\n})(ZoomState || (ZoomState = {}));\nvar usePinchZoom = function usePinchZoom(ref) {\n  var cacheRef = useMemo(function () {\n    return {\n      evCache: [],\n      prevDiff: -1\n    };\n  }, [ref.current]);\n  var _a = useState(),\n    zoomingState = _a[0],\n    setZoomingState = _a[1];\n  var pointermove_handler = function pointermove_handler(ev) {\n    // This function implements a 2-pointer horizontal pinch/zoom gesture.\n    //\n    // If the distance between the two pointers has increased (zoom in),\n    // the target element's background is changed to 'pink' and if the\n    // distance is decreasing (zoom out), the color is changed to 'lightblue'.\n    //\n    // This function sets the target element's border to 'dashed' to visually\n    // indicate the pointer's target received a move event.\n    // Find this event in the cache and update its record with this event\n    for (var i = 0; i < cacheRef.evCache.length; i++) {\n      if (ev.pointerId == cacheRef.evCache[i].pointerId) {\n        cacheRef.evCache[i] = ev;\n        break;\n      }\n    }\n    // If two pointers are down, check for pinch gestures\n    if (cacheRef.evCache.length == 2) {\n      // console.log(prevDiff)\n      // Calculate the distance between the two pointers\n      var curDiff = Math.abs(cacheRef.evCache[0].clientX - cacheRef.evCache[1].clientX);\n      if (cacheRef.prevDiff > 0) {\n        if (curDiff > cacheRef.prevDiff) {\n          // The distance between the two pointers has increased\n          setZoomingState([ZoomState.ZOOMING_IN, curDiff]);\n        }\n        if (curDiff < cacheRef.prevDiff) {\n          // The distance between the two pointers has decreased\n          setZoomingState([ZoomState.ZOOMING_OUT, curDiff]);\n        }\n      }\n      // Cache the distance for the next move event\n      cacheRef.prevDiff = curDiff;\n    }\n  };\n  var pointerdown_handler = function pointerdown_handler(ev) {\n    // The pointerdown event signals the start of a touch interaction.\n    // This event is cached to support 2-finger gestures\n    cacheRef.evCache.push(ev);\n    // console.log('pointerDown', ev);\n  };\n\n  var pointerup_handler = function pointerup_handler(ev) {\n    // Remove this pointer from the cache and reset the target's\n    // background and border\n    remove_event(ev);\n    // If the number of pointers down is less than two then reset diff tracker\n    if (cacheRef.evCache.length < 2) {\n      cacheRef.prevDiff = -1;\n    }\n  };\n  var remove_event = function remove_event(ev) {\n    // Remove this event from the target's cache\n    for (var i = 0; i < cacheRef.evCache.length; i++) {\n      if (cacheRef.evCache[i].pointerId == ev.pointerId) {\n        cacheRef.evCache.splice(i, 1);\n        break;\n      }\n    }\n  };\n  useEffect(function () {\n    if (ref === null || ref === void 0 ? void 0 : ref.current) {\n      ref.current.onpointerdown = pointerdown_handler;\n      ref.current.onpointermove = pointermove_handler;\n      ref.current.onpointerup = pointerup_handler;\n      ref.current.onpointercancel = pointerup_handler;\n      ref.current.onpointerout = pointerup_handler;\n      ref.current.onpointerleave = pointerup_handler;\n    }\n  }, [ref === null || ref === void 0 ? void 0 : ref.current]);\n  return zoomingState ? {\n    zoomingState: zoomingState[0],\n    pinchState: zoomingState[1]\n  } : {\n    zoomingState: null,\n    pinchState: 0\n  };\n};\nexport default usePinchZoom;","map":null,"metadata":{},"sourceType":"module"}